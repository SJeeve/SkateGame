<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>

    var config = {
        type: Phaser.AUTO,
        width: 1600,
        height: 600,
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    class Player extends Phaser.Physics.Arcade.Sprite
    {
        totalJumps = 2;
        currentJumps = 0;
        constructor(scene, x, y)
        {
            super(scene, x, y, 'player');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(2);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000); //We will set gravity *per object* rather than for the scene!
        }
    }


    var game = new Phaser.Game(config);

    //Game Objects
    var platforms;
    var player;

    //Keyboard controls
    var cursors;
    var keys;
    var space;

    var gui;
    var guiTimer;

    function preload()
    {
        this.load.image('sky', 'Assets/clouds.png');
        this.load.image('platform', 'Assets/platform.png');
        this.load.image('player', 'Assets/wabbit.png');
    }

    function create()
    {
        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
       let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);
        let targetVelocity = 800;
       //Create the platforms and the player character set to collide with the platforms
       createPlatforms(this);
       player = new Player(this, -200, 400);
       this.physics.add.collider(player, platforms);

       //Set up user input
       cursors = this.input.keyboard.createCursorKeys();
       keys = this.input.keyboard.addKeys('A, D');
       space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
       space.on('down', jump); //calls jump function when space is pressed

       gui = this.add.text(16, 16, '', {fontSize: '32px', fill: '#000'});
       
       let playerVelocity = 500; // Example velocity, can be any positive number
       player.setVelocityX(playerVelocity);
    }

    function createPlatforms(scene)
    {
        platforms = scene.physics.add.staticGroup();

        //basePlatform is the floor of the game
        let basePlatform = platforms.create(game.scale.width/2, game.scale.height-30, 'platform');
        basePlatform.setScale(3, 1).refreshBody(); //scales the base platform in the x axis to cover the entire floor

        platforms.create(250, 350, 'platform'); //creates the upper left platform
    }

    function update()
    {
        //Player will not move in the x-axis unless a movement key is being pressed

        //Player has "drag" on the x-axis meaning they slide a bit after an input
        player.setDragX(500);
        //This will reset the number of jumps available to the player whenever the player lands
        if (player.body.touching.down) {
            player.currentJumps = 0;
        }
        console.log(player.body.velocity.x);
        if (player.body.velocity.x < 1000)
        {
            player.setAccelerationX(calculateAcceleration(player.body.velocity.x));
        }
    }

    function jump(event)
    {
        if (player.body.touching.down) {
          //If the player is on the ground, the player can jump
          player.setVelocityY(-1100);
          player.currentJumps++;
        } else if (player.currentJumps < player.totalJumps) {
          //If the player is not on the ground but has an available air jump, use that jump
          player.setVelocityY(-800);
          player.currentJumps++;
        }
    }

    //This function is called when a player overlaps with a carrot
    function eatCarrot(player, carrot)
    {
        carrot.disableBody(true, true); //remove that particular carrot from the game (physics and visibility)
        gui.setText('Yum yum!');
        guiTimer = this.time.delayedCall(1000, removeText, [], this);
    }

    //Reset the gui text to be empty after the guiTimer elapses
    function removeText()
    {
        gui.setText('');
    }
    // Function to calculate increased acceleration based on velocity
    function calculateAcceleration(velocity) {
        const accelerationIncreaseFactor = 10.0;
        const acceleration = accelerationIncreaseFactor * Math.log(velocity + 10);
        return acceleration;
    }

    function resize(){
        let canvas = document.querySelector("canvas");
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let windowRatio = windowWidth / windowHeight;
        let gameRatio = game.config.width / game.config.height;
        if(windowRatio < gameRatio)
        {
            canvas.style.width = windowWidth + "px";
            canvas.style.height = (windowWidth / gameRatio) + "px";
        }
        else
        {   
            canvas.style.width = (windowHeight * gameRatio) + "px";
            canvas.style.height = windowHeight + "px";
        }
    }
    </script>

</body>

</html>
